(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{266:function(a,s,e){"use strict";e.r(s);var n=e(28),l=Object(n.a)({},(function(){var a=this,s=a.$createElement,e=a._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"常用范式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#常用范式"}},[a._v("#")]),a._v(" 常用范式")]),a._v(" "),e("h2",{attrs:{id:"泛型范式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#泛型范式"}},[a._v("#")]),a._v(" 泛型范式")]),a._v(" "),e("blockquote",[e("p",[a._v("GP，Generic Programming）—— 抽象你的算法")])]),a._v(" "),e("ul",[e("li",[a._v("基本思想")])]),a._v(" "),e("div",{staticClass:"language-md extra-class"},[e("pre",{pre:!0,attrs:{class:"language-md"}},[e("code",[a._v("将算法和其作用的数据结构分离，并将后者尽可能泛化，最大限度实现算法重用。\n这种泛化是基于模板的参数多态（parameteric polymorphism），\n相比OOp基于继承（inheritance）的子类型多态（subtyping polymorphism），不仅普适性更强，而且效率也更高。\n")])])]),e("ul",[e("li",[a._v("特点")])]),a._v(" "),e("div",{staticClass:"language-md extra-class"},[e("pre",{pre:!0,attrs:{class:"language-md"}},[e("code",[a._v("泛型编程是算法导向的，即以算法为起点和中心点的，逐渐将其所涉及的概念内涵模糊化、外延扩大化，\n将其所涉及的运算抽象化、一般化，从而扩展算法的适用范围。\n（算法串联数据，如脊贯肉；数据实化算法，如肉附脊。）\n")])])]),e("ul",[e("li",[a._v("最著名的代表 —— STL（Standard Template Library）")])]),a._v(" "),e("div",{staticClass:"language-md extra-class"},[e("pre",{pre:!0,attrs:{class:"language-md"}},[e("code",[a._v("起始于C++语言其后亦为Java，C#等吸纳。\n")])])]),e("ul",[e("li",[e("ul",[e("li",[a._v("三个要素")])])])]),a._v(" "),e("div",{staticClass:"language-md extra-class"},[e("pre",{pre:!0,attrs:{class:"language-md"}},[e("code",[a._v("算法（algorithm）\n算法是一系列切实有效的步骤\n\n容器（container）\n容器是数据的集合，可理解为抽象的数组\n\n迭代器（iterator）\n迭代器是算法和容器之间的接口，可以理解为抽象的指针或游标\n")])])]),e("ul",[e("li",[e("ul",[e("li",[a._v("通过模板")])])])]),a._v(" "),e("div",{staticClass:"language-md extra-class"},[e("pre",{pre:!0,attrs:{class:"language-md"}},[e("code",[a._v("泛化了容器——可以是数组、列表、集合、映射、队列、栈、字符串等等\n泛化了元素——可以是任何数据类型\n泛化了处理方法和限定条件——可以是任何函数，还可以是函子（functor）——自带状态的函数对象\n泛化了迭代器——可以从前往后移动，也可以从后往前移动，可以来回移动，可以随机移动，可以按任意预先定义的规律移动。\n")])])]),e("ul",[e("li",[a._v("优势")])]),a._v(" "),e("div",{staticClass:"language-md extra-class"},[e("pre",{pre:!0,attrs:{class:"language-md"}},[e("code",[a._v("泛型使代码简洁，摆脱底层编码的细节，在更高、更抽象的层次上进行编程设计。\n泛型编程不光能泛化概念，还能泛化行为。\n")])])]),e("h2",{attrs:{id:"超级范式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#超级范式"}},[a._v("#")]),a._v(" 超级范式")]),a._v(" "),e("blockquote",[e("p",[a._v("—— 提升语言的级别")])]),a._v(" "),e("ul",[e("li",[a._v("特点")])]),a._v(" "),e("div",{staticClass:"language-md extra-class"},[e("pre",{pre:!0,attrs:{class:"language-md"}},[e("code",[a._v("元编程作为超级范式的一个体现是，它能提升语言的级别。\n如果说OOP的关键在于构造对象的概念，那么LOP的关键在于构造语言的语法。\n\n元程序将程序作为数据来对待，能自我发现、自我赋权和自我升级，\n有着其他程序所不具备的自觉性、自适应性和智能性，可以说是一种最高级的程序。\n\nLOP的关键在于构造语言的语法\n\n在传统的编程中，运算是动态的，但程序本身是静态的。\n在元编程中，二者都是动态的。\n元编程将程序作为数据来对待，能自我发现、自我赋权和自我升级，\n有着其他程序所不具备的自觉性、自适应性和智能性，可以说是一种最高级的编程。\n")])])]),e("ul",[e("li",[a._v("元编程")])]),a._v(" "),e("div",{staticClass:"language-md extra-class"},[e("pre",{pre:!0,attrs:{class:"language-md"}},[e("code",[a._v("模板元编程（Template Metaprogramming），与泛型编程密切相关但是自成一派，\n隶属于另一种编程范式——元编程（MP，Metaprogramming）。\n\n元编程作为超级范式的一个体现是，它能体现语言的级别。\n比如，有了编译器的存在，汇编语言升级为第3代高级语言；\n同样借助Yacc、ANTLR之类的元编程工具，第3代语言升级为第4代DSL语言。\n\n将这一模式发挥至极致，便是更加激进的语言导向式编程（LOP，Language-Oriented Programming）。\n这种编程范式的思路是：在建立一套DSL体系之后，直接用它们来编写软件，尽量不用通用语言。\n")])])]),e("ul",[e("li",[a._v("区别")])]),a._v(" "),e("div",{staticClass:"language-md extra-class"},[e("pre",{pre:!0,attrs:{class:"language-md"}},[e("code",[a._v("问题 \t——>解决办法 ——>通用语言源程序\t——>可执行程序\n通用语言编程  形成概念模型\t  将解法映射到通用语言 编译器编译\n专用语言编程  形成概念模型   将解法映射到专用语言\t  元编程     编译器\n由于DSL比通用语言更简单、更抽象、更专业、更接近自然语言和声明式语言，开发效率显著提高。\n")])])]),e("ul",[e("li",[a._v("应用")])]),a._v(" "),e("div",{staticClass:"language-md extra-class"},[e("pre",{pre:!0,attrs:{class:"language-md"}},[e("code",[a._v("有时程序的结构需要动态改变，而C++、Java、C#等静态语言是不允许动态变更类的成员或实现代码的，\n利用元编程可以突破这种限制。\n\n自动生成源代码的编程也属于另一种编程范式——生产式编程（Generative Programming）的范畴。\n\n区别在于后者更看重代码的生成，而元编程看重的是代码的可执行性。\n\n另外，除了编译期间生成源代码的静态元编程，还有能再运行期间修改程序的动态元编程。\n\n从低级的汇编到一些高级的动态语言，如perl、python、ruby等均支持该功能。\n\n比如许多脚本语言都提供eval函数。\n")])])]),e("h2",{attrs:{id:"切面范式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#切面范式"}},[a._v("#")]),a._v(" 切面范式")]),a._v(" "),e("blockquote",[e("p",[a._v("A（Aspect）OP —— 多角度看问题")])]),a._v(" "),e("ul",[e("li",[a._v("理论")]),a._v(" "),e("li",[e("ul",[e("li",[a._v("定义")])])])]),a._v(" "),e("div",{staticClass:"language-md extra-class"},[e("pre",{pre:!0,attrs:{class:"language-md"}},[e("code",[a._v("宏观上\nAOP是SoC和DIY原则的一种应用\n\n微观上\nAOP虽自OOP土壤中长出，却自成一体，并且嫁接到非OOP领地，不仅在纯过程式编程、函数式编程，\n甚至逻辑式语言中得到发展，而且本身也具备一定的声明式语言的特征，成为一种新的软件模块化方法\n")])])]),e("ul",[e("li",[e("ul",[e("li",[a._v("问题")])])])]),a._v(" "),e("div",{staticClass:"language-md extra-class"},[e("pre",{pre:!0,attrs:{class:"language-md"}},[e("code",[a._v("不良代码通常有两种病症\n结构混乱，或聚至纠缠打结、或散至七零八落\n代码重复，叠床架屋、臃肿不堪\n\n解决这些问题的一个有效方法是 抽象与分解\n从问题中抽象出一些关注点，再以此为基础进行分解\n分解后的子问题主题鲜明且独立完备，即不会牵一发动全身，也不会四分五裂、支离破碎\n同时具有相同特征的部分可以像代数中的公因子一样提取出来，提高了重用性，减少了重复性\n")])])]),e("ul",[e("li",[e("ul",[e("li",[a._v("特点")])])])]),a._v(" "),e("div",{staticClass:"language-md extra-class"},[e("pre",{pre:!0,attrs:{class:"language-md"}},[e("code",[a._v("AOP将程序抽象为分解为切面\n\nAOP以切面为模块，它描述的是横切关注点（cross-cutting concerns），\n即与程序的纵向主流执行方向横向正交的关注焦点。\n\n不妨回顾下，无论是过程式的函数，还是对象式的方法，都包含了完成的执行代码。\n但有些代码横跨了多个模块，以片段的形式散落在各处，\n虽具有相似的逻辑，却无法用传统的方法提炼成模块，难以实现SoC和DRY。\n典型的例子如：\n在调用某些对象的方法，读写某些对象的域、抛出某些异常等前后需要用到统一的业务逻辑，\n诸如日志输出、代码跟踪、性能监控、异常处理、安全检查、事务管理，等等。\n为了解决此类问题，AOP应运而生。\n\n它将每类横切关注封装到单独的Aspect 模块中，将程序中的一些执行点和相应的代码绑定起来。\n\n单个的执行点称为接入点（join point）\n调用某个对象的方法前后\n符合预先指定条件的接入点集合称为切入点（pointcut）\n所有一set为命名开头的方法；每段绑定的代码称为一个建议（advice）\n\n接入处是点，切入处是面，面由点组成，advice定义于切入点上，执行于接入点处。\n")])])]),e("ul",[e("li",[e("ul",[e("li",[a._v("原理")])])])]),a._v(" "),e("div",{staticClass:"language-md extra-class"},[e("pre",{pre:!0,attrs:{class:"language-md"}},[e("code",[a._v("如果一个程序是一个管道系统，AOP就是在管道上钻一些孔，在每个孔中注入新的代码流。\n\n因此AOP的关键是将advice的代码嵌入到主题程序中，术语称为编织（weaving）\n静态编织，通过修改源码和字节码在编译期、后编译期和加载期嵌入代码——请注意，\n这里涉及刚才提到的元编程和产生式编程；\n动态编织，通过代理等技术在运行期实现嵌入。\n")])])]),e("ul",[e("li",[e("ul",[e("li",[a._v("举例")])])])]),a._v(" "),e("div",{staticClass:"language-md extra-class"},[e("pre",{pre:!0,attrs:{class:"language-md"}},[e("code",[a._v("举例，白光经过三棱镜的折射分解为七色光，是谓光的色散。再经过导致的三棱镜，七色光又重新汇聚为白色。\n如果把一个复杂的系统比作复合色的白光，经过第一个三棱镜——关注分离器，系统被分解为不同的切面，\n如果不同的单色的采光。这些切面经过第二个三棱镜——编织器，再度合成为原系统\n")])])]),e("ul",[e("li",[a._v("AOP 与 OOP")])]),a._v(" "),e("div",{staticClass:"language-md extra-class"},[e("pre",{pre:!0,attrs:{class:"language-md"}},[e("code",[a._v("OOP只能沿着继承树的纵向方向重用，而AOP弥补了OOP的不足，可以再横向方向重用\nOP是OOP的一种补充，尽管AOP不局限于OOP\n")])])]),e("ul",[e("li",[a._v("应用")])]),a._v(" "),e("div",{staticClass:"language-md extra-class"},[e("pre",{pre:!0,attrs:{class:"language-md"}},[e("code",[a._v("具体的工具包括一些扩展性语言如 AspectJ、AspectC++、Aspect#等和一些框架如 AspectWerkz、Spring、Jboss AOP等。\n\n与OOP一样，AOP在带来便利的同时，也增加了一定的复杂度和性能损耗。\n它适用于大中型程序，用在小型程序中则不啻牛刀杀鸡。\n")])])]),e("ul",[e("li",[e("ul",[e("li",[a._v("步骤")])])])]),a._v(" "),e("div",{staticClass:"language-md extra-class"},[e("pre",{pre:!0,attrs:{class:"language-md"}},[e("code",[a._v("分解切面 —— 第一步在设计者的头脑中进行\n实现切面 —— 第二步需要程序员编码实现，即分别实现各个切面的advice，并指明advice挂靠的切入点\n合成切面 —— 第三步是通过AOP的工具实现的\n")])])]),e("h2",{attrs:{id:"事件驱动"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#事件驱动"}},[a._v("#")]),a._v(" 事件驱动")]),a._v(" "),e("blockquote",[e("p",[a._v("—— 有事叫我叫你，没事别烦我")])]),a._v(" "),e("ul",[e("li",[a._v("理论")]),a._v(" "),e("li",[e("ul",[e("li",[a._v("事件")])])])]),a._v(" "),e("div",{staticClass:"language-md extra-class"},[e("pre",{pre:!0,attrs:{class:"language-md"}},[e("code",[a._v("在软件中，它一般表现为一个程序的某些信息状态上的变化\n")])])]),e("ul",[e("li",[e("ul",[e("li",[e("ul",[e("li",[a._v("分类")])])])])])]),a._v(" "),e("div",{staticClass:"language-md extra-class"},[e("pre",{pre:!0,attrs:{class:"language-md"}},[e("code",[a._v("基于事件驱动的系统一般提供两类内建事件（built-in event）\n底层事件（low-level event） 和 原生事件（native event），\n在用户图形界面（GUI）系统中，这列事件直接由鼠标、键盘等硬件设备触发；\n\n语义事件（semantic event），一般代表用户的行为逻辑，是若干底层时间的组合。\n比如鼠标拖放（drag-and-drop）多表示移动被拖放的对象，由鼠标按下、鼠标移动和鼠标释放三个底层事件组成。\n\n用户自定义事件（user-defined event）\n他们可以是在原有的内建事件基础上进行的包装，也可以是纯粹的虚拟事件（virtual event）。\n\n除此之外，编程者不但能定义事件还能产生事件。虽然大部分事件是由外界激发的自然事件（natural event），\n但有时程序员需要主动激发一些事件，如果模拟用户鼠标点击或键盘输入等，这类事件被称为合成事件（synthetic event）。\n")])])]),e("ul",[e("li",[e("ul",[e("li",[e("ul",[e("li",[a._v("事件 & 消息")])])])])])]),a._v(" "),e("div",{staticClass:"language-md extra-class"},[e("pre",{pre:!0,attrs:{class:"language-md"}},[e("code",[a._v("消息是Windows内部醉基本的通信方式，事件需要消息来传递，是消息的主要来源\n\n每当用户触发一个事件，如移动鼠标或敲击键盘，系统都会将其转化为消息并放入相应程序的消息队列（messge queue）中。\n\n在消息循环中，程序通过GetMessage不断地从消息队列中获取消息，\n经过TranslateMessage预处理后再通过DispatchMessage将消息送交窗口过程WndProc处理。\n")])])]),e("ul",[e("li",[e("ul",[e("li",[a._v("流程驱动式编程 & 事件驱动式编程")])])])]),a._v(" "),e("div",{staticClass:"language-md extra-class"},[e("pre",{pre:!0,attrs:{class:"language-md"}},[e("code",[a._v("（Flow-Driven Programming）采用主动轮询（polling），行为取决于自身的观察判断，是流程驱动的 —— 公共汽车 预定路线\n（Event-Driven Programming，简称EDP）采用被动等通知，行为取决于外来的突发事件，是事件驱动的 —— 出租车 用户触发\n")])])]),e("ul",[e("li",[e("ul",[e("li",[a._v("概念")])])]),a._v(" "),e("li",[e("ul",[e("li",[e("ul",[e("li",[a._v("“回调”")])])])])])]),a._v(" "),e("div",{staticClass:"language-md extra-class"},[e("pre",{pre:!0,attrs:{class:"language-md"}},[e("code",[a._v("强调的是行为方式——低层反调高层，而“抽象接口”强调的是实现方式——正式由于接口具有抽象性，低层才能在调用它时无须虑及高层的具体实现\n\n同步回调和异步回调都使调用者不再依赖被调用者，将二者从代码上解耦，异步调用更将二者从时间上解耦\n\n在软件模块分层中，低层模块为为高层模块提供服务，并且不能依赖高层模块，以保证其可重用性；\n通常被调用者（Callee）为调用者（Caller）提供服务，调用者依赖被调者。两相结合，决定了底层模块多为被调用者，高层模块多为调用者。\n但低层模块为了追求更强的普适性和可扩展性，有事也有调用高层模块的需求，于是便邀callback前来相助。\n")])])]),e("div",{staticClass:"language-md extra-class"},[e("pre",{pre:!0,attrs:{class:"language-md"}},[e("code",[a._v("控制反转、依赖反转和依赖注射的主题是控制和依赖，目的是解耦，方法是反转，而实现这一切的关键是抽象接口\n回调函数的提法较为古老，多出现于过程式编程，抽象接口是更现代，更OO的说法。\n\n从字面上看，‘回调’强调的是行为方式——低层反调高层，而‘抽象接口’强调实现的方式——正式由于接口的抽象性，\n低层才能在调用它时，无需虑及高层的具体细节，从而实现控制反转。\n")])])]),e("ul",[e("li",[e("ul",[e("li",[a._v("特征")])])])]),a._v(" "),e("div",{staticClass:"language-md extra-class"},[e("pre",{pre:!0,attrs:{class:"language-md"}},[e("code",[a._v("被动性 - 来自于控制反转\n控制反转的主要作用是降低模块之间的依赖性，从而降低模块的耦合度和复杂度，\n提高软件的可重用性、柔韧性和可扩展性，但对可伸缩性并无太大帮助\n一般通过Callback实现，其目的是降低模块之间的依赖，从而降低模块的的耦合度和复杂度\n\n异步性 - 来自于会话切换\n由事件的不可预测性和随机性决定的\n独立是异步的前提，耗时是异步的理由\n异步过程在主程序中已非堵塞的机制运行，即主程序不必等待该过程的返回就能继续下一步。\n异步机制能减少随机因素造成的资源浪费，提高系统的性能和可伸缩性。\n")])])]),e("ul",[e("li",[a._v("实现")])]),a._v(" "),e("blockquote",[e("p",[a._v("步骤")])]),a._v(" "),e("div",{staticClass:"language-md extra-class"},[e("pre",{pre:!0,attrs:{class:"language-md"}},[e("code",[a._v("实现事件处理器\n注册事件处理器\n实现事件循环\n")])])]),e("blockquote",[e("p",[a._v("事件机制设计需考虑的问题")])]),a._v(" "),e("div",{staticClass:"language-md extra-class"},[e("pre",{pre:!0,attrs:{class:"language-md"}},[e("code",[a._v("事件定义、事件触发、事件侦查、事件转化、事件合并、事件调度、事件传播、事件处理、事件连带（event cascade）等。\n")])])]),e("blockquote",[e("p",[a._v("一个典型的事件驱动模块")])]),a._v(" "),e("div",{staticClass:"language-md extra-class"},[e("pre",{pre:!0,attrs:{class:"language-md"}},[e("code",[a._v("事件处理器事先在关注的事件源上注册，后者不定期地发表事件对象，\n经过事件管理器的转化（translate）、合并（coalesce）、排队（enquence）、分派（dispatch）等集中处理后，\n事件处理器接收到事件并对其进行相应的处理。\n")])])]),e("ul",[e("li",[a._v("应用")])]),a._v(" "),e("div",{staticClass:"language-md extra-class"},[e("pre",{pre:!0,attrs:{class:"language-md"}},[e("code",[a._v("如果一个应用中，存在一些该类特质的因素，比如频繁的出现堵塞呼叫（blocking call），不妨考虑将其包装为事件\n\n发行/订阅模式（publish-subscribe pattern）正是 观察者模式（observer pattern）的别名，\n一方面可看作简化或退化的事件驱动式，另一方面可看作事件驱动式的核心思想。\n该模式省略了事件管理器部分，由事件源直接调用事件处理器的接口。\n\nMVC架构是观察者模式在架构设计上的一个应用\n")])])])])}),[],!1,null,null,null);s.default=l.exports}}]);