(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{275:function(a,s,t){"use strict";t.r(s);var e=t(28),n=Object(e.a)({},(function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"软件应变-随需而变，适者生存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#软件应变-随需而变，适者生存"}},[a._v("#")]),a._v(" 软件应变——随需而变，适者生存")]),a._v(" "),t("h2",{attrs:{id:"概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#概念"}},[a._v("#")]),a._v(" 概念")]),a._v(" "),t("div",{staticClass:"language-md extra-class"},[t("pre",{pre:!0,attrs:{class:"language-md"}},[t("code",[a._v("抽象接口描述了一个类的最本质的行为特征，具体实现随时可能变化，\n隐藏他们可以保证这种变动不会波及客户代码。\n\n软件和硬件的区别，不仅是无形和有形之别，更是变化和固化之别。\n\t所谓变化，值源代码随时可能因需而变。\n\t一个软件的修改维护时间通常会大大超过编写时间，越复杂越成熟的程序越是如此。\n")])])]),t("h2",{attrs:{id:"编程的两个难点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#编程的两个难点"}},[a._v("#")]),a._v(" 编程的两个难点")]),a._v(" "),t("div",{staticClass:"language-md extra-class"},[t("pre",{pre:!0,attrs:{class:"language-md"}},[t("code",[a._v("其一是逻辑的复杂性\n其二是需求的变化性\n")])])]),t("ul",[t("li",[a._v("误区")])]),a._v(" "),t("div",{staticClass:"language-md extra-class"},[t("pre",{pre:!0,attrs:{class:"language-md"}},[t("code",[a._v("许多程序员看重前置忽略后者，大部分时间花在需求解决方案上，而不是在选择解决方案上。\n充满技巧的代码不仅难于理解易于出错，而且普适性低而受变化的冲击更大。\n过度设计带来不必要的复杂和效率损失。\n")])])]),t("ul",[t("li",[a._v("软件之软，体现在适应变化的能力")])]),a._v(" "),t("div",{staticClass:"language-md extra-class"},[t("pre",{pre:!0,attrs:{class:"language-md"}},[t("code",[a._v("质量低下的软件并不是不能变化，而是在变化面前不能应付自如。\n\t一般表现为僵硬、敏感而脆弱，一有风吹草动，往往东修西补，难免顾此失彼。\n\n因此许多编程设计思想包括OOP都以提高应变能力为主题的，抽象和封装便是代表。\n\t抽象一个对象模型是将一类对象最本质、最不易变化的部分提炼出来，\n\t封装——更准确说是信息隐藏则是将非本质、容易变化的部分隐藏起来，从而将一个类划分为阴阳两面。\n")])])]),t("h2",{attrs:{id:"软件的变化大致分为两种"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#软件的变化大致分为两种"}},[a._v("#")]),a._v(" 软件的变化大致分为两种")]),a._v(" "),t("div",{staticClass:"language-md extra-class"},[t("pre",{pre:!0,attrs:{class:"language-md"}},[t("code",[a._v("一种是内在需求而作的结构性变化，通常以改善软件质量为目的，\n  包括代码重构、性能调优（performance tuning），等等\n\n一种是处于外在需求而作的功能性变化，通常以满足客户需求为目的。\n")])])]),t("div",{staticClass:"language-md extra-class"},[t("pre",{pre:!0,attrs:{class:"language-md"}},[t("code",[a._v("理想的抽象与封装，应能完全避免第一类变化对客户代码的影响，\n也能最大限度地降低第二类变化带来的副作用。\n")])])]),t("h2",{attrs:{id:"实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实现"}},[a._v("#")]),a._v(" 实现")]),a._v(" "),t("div",{staticClass:"language-md extra-class"},[t("pre",{pre:!0,attrs:{class:"language-md"}},[t("code",[a._v("桥梁模式（bridge pattern），可以将接口和实现完全分开。（P222）\n\n在C++中常被称为Pimpl惯用法（Pointer to Implementation idiom），\n也称为编译器防火墙惯用法、句柄类（handle classes）、不透明指针（opaque pointer）、柴郡猫（Cheshire Cat）等。\n\n但严格来说，桥梁模式与Pimpl的侧重点不同，前者是将抽象从实现中解耦的一种设计模式，\n后者主要是表现为一种减少编译依赖和编译时间的编程技巧。\n")])])]),t("h2",{attrs:{id:"原则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#原则"}},[a._v("#")]),a._v(" 原则")]),a._v(" "),t("div",{staticClass:"language-md extra-class"},[t("pre",{pre:!0,attrs:{class:"language-md"}},[t("code",[a._v("代码的改动量和改动范围当然越小越好，但更重要的是哪里该改动、哪里该不动。\n")])])]),t("ul",[t("li",[a._v("开闭原则（open/closed principle，OCP）对扩展开放，对修改封闭。")])]),a._v(" "),t("div",{staticClass:"language-md extra-class"},[t("pre",{pre:!0,attrs:{class:"language-md"}},[t("code",[a._v("软件应该在模块的基础上进行扩展，而不是修改。换言之，严格遵守开闭原则的软件，不应该改老代码，只能新增代码。\n\n要实现这点，最关键还是抽象。抽象的模块因稳定而很少需要修改，因普适而便于扩展。\n\n诚然百分之百不修改原有代码时过于理想化了，但越基础、越是核心的模块越应该遵守这个原则。\n\t平时使用的类库、框架就是最好的例子。\n\n如果类库提供的服务不能满足需求，客户一般通过接口（interface）、多态（polymorphism，[,pɒlɪ'mɔːfɪz(ə)m]）、\n继承（inheritance）、合成（composition）等技巧来扩展相关的类；\n\n如果框架提供的服务不能满足要求，客户一般通过框架开放的各种可扩展的点来嵌入新模块。\n\n无论哪种情况，需要修改的都是享受服务的客户代码，而不是提供服务的基础代码。\n")])])]),t("h2",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[a._v("#")]),a._v(" 总结")]),a._v(" "),t("div",{staticClass:"language-md extra-class"},[t("pre",{pre:!0,attrs:{class:"language-md"}},[t("code",[a._v("软件要想有高度的可重用性，必须以高度的应变性为前提。\n当然，这并不意味着类库和框架不能变，但这些变化是出于功能改善、性能改进等方面的需要，\n不会因个别客户的具体需求而变，并且应以不破坏现有客户为原则的。\n")])])])])}),[],!1,null,null,null);s.default=n.exports}}]);