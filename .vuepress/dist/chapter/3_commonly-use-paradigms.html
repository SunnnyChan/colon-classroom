<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>常用范式 | 冒号课堂</title>
    <meta name="description" content="">
    <meta name="generator" content="VuePress 1.4.0">
    
    
    <link rel="preload" href="/colon-classroom/assets/css/0.styles.66c7515b.css" as="style"><link rel="preload" href="/colon-classroom/assets/js/app.ec0b5e36.js" as="script"><link rel="preload" href="/colon-classroom/assets/js/2.8729a11c.js" as="script"><link rel="preload" href="/colon-classroom/assets/js/22.eccee837.js" as="script"><link rel="prefetch" href="/colon-classroom/assets/js/10.368bea65.js"><link rel="prefetch" href="/colon-classroom/assets/js/11.d2f0a483.js"><link rel="prefetch" href="/colon-classroom/assets/js/12.33727165.js"><link rel="prefetch" href="/colon-classroom/assets/js/13.c3807870.js"><link rel="prefetch" href="/colon-classroom/assets/js/14.4422a58e.js"><link rel="prefetch" href="/colon-classroom/assets/js/15.9a6e94e2.js"><link rel="prefetch" href="/colon-classroom/assets/js/16.355473a7.js"><link rel="prefetch" href="/colon-classroom/assets/js/17.ad77ae48.js"><link rel="prefetch" href="/colon-classroom/assets/js/18.e04ab935.js"><link rel="prefetch" href="/colon-classroom/assets/js/19.2628013f.js"><link rel="prefetch" href="/colon-classroom/assets/js/20.53a11e89.js"><link rel="prefetch" href="/colon-classroom/assets/js/21.f9792c66.js"><link rel="prefetch" href="/colon-classroom/assets/js/23.8c12f11d.js"><link rel="prefetch" href="/colon-classroom/assets/js/24.730c0eba.js"><link rel="prefetch" href="/colon-classroom/assets/js/25.1ea088d3.js"><link rel="prefetch" href="/colon-classroom/assets/js/26.a7f69969.js"><link rel="prefetch" href="/colon-classroom/assets/js/27.32626129.js"><link rel="prefetch" href="/colon-classroom/assets/js/28.93b30a44.js"><link rel="prefetch" href="/colon-classroom/assets/js/29.b0358f74.js"><link rel="prefetch" href="/colon-classroom/assets/js/3.29adc69c.js"><link rel="prefetch" href="/colon-classroom/assets/js/30.4f474b68.js"><link rel="prefetch" href="/colon-classroom/assets/js/31.9b1e9d94.js"><link rel="prefetch" href="/colon-classroom/assets/js/32.bad2713e.js"><link rel="prefetch" href="/colon-classroom/assets/js/33.ffc77d35.js"><link rel="prefetch" href="/colon-classroom/assets/js/34.b681b0f9.js"><link rel="prefetch" href="/colon-classroom/assets/js/35.995c72ed.js"><link rel="prefetch" href="/colon-classroom/assets/js/36.a7343326.js"><link rel="prefetch" href="/colon-classroom/assets/js/37.1499c16f.js"><link rel="prefetch" href="/colon-classroom/assets/js/38.c6f3c4b1.js"><link rel="prefetch" href="/colon-classroom/assets/js/39.13970ecf.js"><link rel="prefetch" href="/colon-classroom/assets/js/4.5f60d4ea.js"><link rel="prefetch" href="/colon-classroom/assets/js/40.31f6b10b.js"><link rel="prefetch" href="/colon-classroom/assets/js/41.8bd8d456.js"><link rel="prefetch" href="/colon-classroom/assets/js/42.ae600a4f.js"><link rel="prefetch" href="/colon-classroom/assets/js/43.9590bd29.js"><link rel="prefetch" href="/colon-classroom/assets/js/5.d7aeab17.js"><link rel="prefetch" href="/colon-classroom/assets/js/6.f3a0310a.js"><link rel="prefetch" href="/colon-classroom/assets/js/7.8f9f5f9a.js"><link rel="prefetch" href="/colon-classroom/assets/js/8.dbb58cf6.js"><link rel="prefetch" href="/colon-classroom/assets/js/9.0193b6be.js">
    <link rel="stylesheet" href="/colon-classroom/assets/css/0.styles.66c7515b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/colon-classroom/" class="home-link router-link-active"><!----> <span class="site-name">冒号课堂</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="http://www.github.com/sunnnychan" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="http://www.github.com/sunnnychan" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/colon-classroom/chapter/" class="sidebar-link">章节</a></li><li><a href="/colon-classroom/notes/" class="sidebar-link">参考</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="常用范式"><a href="#常用范式" class="header-anchor">#</a> 常用范式</h1> <h2 id="泛型范式"><a href="#泛型范式" class="header-anchor">#</a> 泛型范式</h2> <blockquote><p>GP，Generic Programming）—— 抽象你的算法</p></blockquote> <ul><li>基本思想</li></ul> <div class="language-md extra-class"><pre class="language-md"><code>将算法和其作用的数据结构分离，并将后者尽可能泛化，最大限度实现算法重用。
这种泛化是基于模板的参数多态（parameteric polymorphism），
相比OOp基于继承（inheritance）的子类型多态（subtyping polymorphism），不仅普适性更强，而且效率也更高。
</code></pre></div><ul><li>特点</li></ul> <div class="language-md extra-class"><pre class="language-md"><code>泛型编程是算法导向的，即以算法为起点和中心点的，逐渐将其所涉及的概念内涵模糊化、外延扩大化，
将其所涉及的运算抽象化、一般化，从而扩展算法的适用范围。
（算法串联数据，如脊贯肉；数据实化算法，如肉附脊。）
</code></pre></div><ul><li>最著名的代表 —— STL（Standard Template Library）</li></ul> <div class="language-md extra-class"><pre class="language-md"><code>起始于C++语言其后亦为Java，C#等吸纳。
</code></pre></div><ul><li><ul><li>三个要素</li></ul></li></ul> <div class="language-md extra-class"><pre class="language-md"><code>算法（algorithm）
算法是一系列切实有效的步骤

容器（container）
容器是数据的集合，可理解为抽象的数组

迭代器（iterator）
迭代器是算法和容器之间的接口，可以理解为抽象的指针或游标
</code></pre></div><ul><li><ul><li>通过模板</li></ul></li></ul> <div class="language-md extra-class"><pre class="language-md"><code>泛化了容器——可以是数组、列表、集合、映射、队列、栈、字符串等等
泛化了元素——可以是任何数据类型
泛化了处理方法和限定条件——可以是任何函数，还可以是函子（functor）——自带状态的函数对象
泛化了迭代器——可以从前往后移动，也可以从后往前移动，可以来回移动，可以随机移动，可以按任意预先定义的规律移动。
</code></pre></div><ul><li>优势</li></ul> <div class="language-md extra-class"><pre class="language-md"><code>泛型使代码简洁，摆脱底层编码的细节，在更高、更抽象的层次上进行编程设计。
泛型编程不光能泛化概念，还能泛化行为。
</code></pre></div><h2 id="超级范式"><a href="#超级范式" class="header-anchor">#</a> 超级范式</h2> <blockquote><p>—— 提升语言的级别</p></blockquote> <ul><li>特点</li></ul> <div class="language-md extra-class"><pre class="language-md"><code>元编程作为超级范式的一个体现是，它能提升语言的级别。
如果说OOP的关键在于构造对象的概念，那么LOP的关键在于构造语言的语法。

元程序将程序作为数据来对待，能自我发现、自我赋权和自我升级，
有着其他程序所不具备的自觉性、自适应性和智能性，可以说是一种最高级的程序。

LOP的关键在于构造语言的语法

在传统的编程中，运算是动态的，但程序本身是静态的。
在元编程中，二者都是动态的。
元编程将程序作为数据来对待，能自我发现、自我赋权和自我升级，
有着其他程序所不具备的自觉性、自适应性和智能性，可以说是一种最高级的编程。
</code></pre></div><ul><li>元编程</li></ul> <div class="language-md extra-class"><pre class="language-md"><code>模板元编程（Template Metaprogramming），与泛型编程密切相关但是自成一派，
隶属于另一种编程范式——元编程（MP，Metaprogramming）。

元编程作为超级范式的一个体现是，它能体现语言的级别。
比如，有了编译器的存在，汇编语言升级为第3代高级语言；
同样借助Yacc、ANTLR之类的元编程工具，第3代语言升级为第4代DSL语言。

将这一模式发挥至极致，便是更加激进的语言导向式编程（LOP，Language-Oriented Programming）。
这种编程范式的思路是：在建立一套DSL体系之后，直接用它们来编写软件，尽量不用通用语言。
</code></pre></div><ul><li>区别</li></ul> <div class="language-md extra-class"><pre class="language-md"><code>问题 	——&gt;解决办法 ——&gt;通用语言源程序	——&gt;可执行程序
通用语言编程  形成概念模型	  将解法映射到通用语言 编译器编译
专用语言编程  形成概念模型   将解法映射到专用语言	  元编程     编译器
由于DSL比通用语言更简单、更抽象、更专业、更接近自然语言和声明式语言，开发效率显著提高。
</code></pre></div><ul><li>应用</li></ul> <div class="language-md extra-class"><pre class="language-md"><code>有时程序的结构需要动态改变，而C++、Java、C#等静态语言是不允许动态变更类的成员或实现代码的，
利用元编程可以突破这种限制。

自动生成源代码的编程也属于另一种编程范式——生产式编程（Generative Programming）的范畴。

区别在于后者更看重代码的生成，而元编程看重的是代码的可执行性。

另外，除了编译期间生成源代码的静态元编程，还有能再运行期间修改程序的动态元编程。

从低级的汇编到一些高级的动态语言，如perl、python、ruby等均支持该功能。

比如许多脚本语言都提供eval函数。
</code></pre></div><h2 id="切面范式"><a href="#切面范式" class="header-anchor">#</a> 切面范式</h2> <blockquote><p>A（Aspect）OP —— 多角度看问题</p></blockquote> <ul><li>理论</li> <li><ul><li>定义</li></ul></li></ul> <div class="language-md extra-class"><pre class="language-md"><code>宏观上
AOP是SoC和DIY原则的一种应用

微观上
AOP虽自OOP土壤中长出，却自成一体，并且嫁接到非OOP领地，不仅在纯过程式编程、函数式编程，
甚至逻辑式语言中得到发展，而且本身也具备一定的声明式语言的特征，成为一种新的软件模块化方法
</code></pre></div><ul><li><ul><li>问题</li></ul></li></ul> <div class="language-md extra-class"><pre class="language-md"><code>不良代码通常有两种病症
结构混乱，或聚至纠缠打结、或散至七零八落
代码重复，叠床架屋、臃肿不堪

解决这些问题的一个有效方法是 抽象与分解
从问题中抽象出一些关注点，再以此为基础进行分解
分解后的子问题主题鲜明且独立完备，即不会牵一发动全身，也不会四分五裂、支离破碎
同时具有相同特征的部分可以像代数中的公因子一样提取出来，提高了重用性，减少了重复性
</code></pre></div><ul><li><ul><li>特点</li></ul></li></ul> <div class="language-md extra-class"><pre class="language-md"><code>AOP将程序抽象为分解为切面

AOP以切面为模块，它描述的是横切关注点（cross-cutting concerns），
即与程序的纵向主流执行方向横向正交的关注焦点。

不妨回顾下，无论是过程式的函数，还是对象式的方法，都包含了完成的执行代码。
但有些代码横跨了多个模块，以片段的形式散落在各处，
虽具有相似的逻辑，却无法用传统的方法提炼成模块，难以实现SoC和DRY。
典型的例子如：
在调用某些对象的方法，读写某些对象的域、抛出某些异常等前后需要用到统一的业务逻辑，
诸如日志输出、代码跟踪、性能监控、异常处理、安全检查、事务管理，等等。
为了解决此类问题，AOP应运而生。

它将每类横切关注封装到单独的Aspect 模块中，将程序中的一些执行点和相应的代码绑定起来。

单个的执行点称为接入点（join point）
调用某个对象的方法前后
符合预先指定条件的接入点集合称为切入点（pointcut）
所有一set为命名开头的方法；每段绑定的代码称为一个建议（advice）

接入处是点，切入处是面，面由点组成，advice定义于切入点上，执行于接入点处。
</code></pre></div><ul><li><ul><li>原理</li></ul></li></ul> <div class="language-md extra-class"><pre class="language-md"><code>如果一个程序是一个管道系统，AOP就是在管道上钻一些孔，在每个孔中注入新的代码流。

因此AOP的关键是将advice的代码嵌入到主题程序中，术语称为编织（weaving）
静态编织，通过修改源码和字节码在编译期、后编译期和加载期嵌入代码——请注意，
这里涉及刚才提到的元编程和产生式编程；
动态编织，通过代理等技术在运行期实现嵌入。
</code></pre></div><ul><li><ul><li>举例</li></ul></li></ul> <div class="language-md extra-class"><pre class="language-md"><code>举例，白光经过三棱镜的折射分解为七色光，是谓光的色散。再经过导致的三棱镜，七色光又重新汇聚为白色。
如果把一个复杂的系统比作复合色的白光，经过第一个三棱镜——关注分离器，系统被分解为不同的切面，
如果不同的单色的采光。这些切面经过第二个三棱镜——编织器，再度合成为原系统
</code></pre></div><ul><li>AOP 与 OOP</li></ul> <div class="language-md extra-class"><pre class="language-md"><code>OOP只能沿着继承树的纵向方向重用，而AOP弥补了OOP的不足，可以再横向方向重用
OP是OOP的一种补充，尽管AOP不局限于OOP
</code></pre></div><ul><li>应用</li></ul> <div class="language-md extra-class"><pre class="language-md"><code>具体的工具包括一些扩展性语言如 AspectJ、AspectC++、Aspect#等和一些框架如 AspectWerkz、Spring、Jboss AOP等。

与OOP一样，AOP在带来便利的同时，也增加了一定的复杂度和性能损耗。
它适用于大中型程序，用在小型程序中则不啻牛刀杀鸡。
</code></pre></div><ul><li><ul><li>步骤</li></ul></li></ul> <div class="language-md extra-class"><pre class="language-md"><code>分解切面 —— 第一步在设计者的头脑中进行
实现切面 —— 第二步需要程序员编码实现，即分别实现各个切面的advice，并指明advice挂靠的切入点
合成切面 —— 第三步是通过AOP的工具实现的
</code></pre></div><h2 id="事件驱动"><a href="#事件驱动" class="header-anchor">#</a> 事件驱动</h2> <blockquote><p>—— 有事叫我叫你，没事别烦我</p></blockquote> <ul><li>理论</li> <li><ul><li>事件</li></ul></li></ul> <div class="language-md extra-class"><pre class="language-md"><code>在软件中，它一般表现为一个程序的某些信息状态上的变化
</code></pre></div><ul><li><ul><li><ul><li>分类</li></ul></li></ul></li></ul> <div class="language-md extra-class"><pre class="language-md"><code>基于事件驱动的系统一般提供两类内建事件（built-in event）
底层事件（low-level event） 和 原生事件（native event），
在用户图形界面（GUI）系统中，这列事件直接由鼠标、键盘等硬件设备触发；

语义事件（semantic event），一般代表用户的行为逻辑，是若干底层时间的组合。
比如鼠标拖放（drag-and-drop）多表示移动被拖放的对象，由鼠标按下、鼠标移动和鼠标释放三个底层事件组成。

用户自定义事件（user-defined event）
他们可以是在原有的内建事件基础上进行的包装，也可以是纯粹的虚拟事件（virtual event）。

除此之外，编程者不但能定义事件还能产生事件。虽然大部分事件是由外界激发的自然事件（natural event），
但有时程序员需要主动激发一些事件，如果模拟用户鼠标点击或键盘输入等，这类事件被称为合成事件（synthetic event）。
</code></pre></div><ul><li><ul><li><ul><li>事件 &amp; 消息</li></ul></li></ul></li></ul> <div class="language-md extra-class"><pre class="language-md"><code>消息是Windows内部醉基本的通信方式，事件需要消息来传递，是消息的主要来源

每当用户触发一个事件，如移动鼠标或敲击键盘，系统都会将其转化为消息并放入相应程序的消息队列（messge queue）中。

在消息循环中，程序通过GetMessage不断地从消息队列中获取消息，
经过TranslateMessage预处理后再通过DispatchMessage将消息送交窗口过程WndProc处理。
</code></pre></div><ul><li><ul><li>流程驱动式编程 &amp; 事件驱动式编程</li></ul></li></ul> <div class="language-md extra-class"><pre class="language-md"><code>（Flow-Driven Programming）采用主动轮询（polling），行为取决于自身的观察判断，是流程驱动的 —— 公共汽车 预定路线
（Event-Driven Programming，简称EDP）采用被动等通知，行为取决于外来的突发事件，是事件驱动的 —— 出租车 用户触发
</code></pre></div><ul><li><ul><li>概念</li></ul></li> <li><ul><li><ul><li>“回调”</li></ul></li></ul></li></ul> <div class="language-md extra-class"><pre class="language-md"><code>强调的是行为方式——低层反调高层，而“抽象接口”强调的是实现方式——正式由于接口具有抽象性，低层才能在调用它时无须虑及高层的具体实现

同步回调和异步回调都使调用者不再依赖被调用者，将二者从代码上解耦，异步调用更将二者从时间上解耦

在软件模块分层中，低层模块为为高层模块提供服务，并且不能依赖高层模块，以保证其可重用性；
通常被调用者（Callee）为调用者（Caller）提供服务，调用者依赖被调者。两相结合，决定了底层模块多为被调用者，高层模块多为调用者。
但低层模块为了追求更强的普适性和可扩展性，有事也有调用高层模块的需求，于是便邀callback前来相助。
</code></pre></div><div class="language-md extra-class"><pre class="language-md"><code>控制反转、依赖反转和依赖注射的主题是控制和依赖，目的是解耦，方法是反转，而实现这一切的关键是抽象接口
回调函数的提法较为古老，多出现于过程式编程，抽象接口是更现代，更OO的说法。

从字面上看，‘回调’强调的是行为方式——低层反调高层，而‘抽象接口’强调实现的方式——正式由于接口的抽象性，
低层才能在调用它时，无需虑及高层的具体细节，从而实现控制反转。
</code></pre></div><ul><li><ul><li>特征</li></ul></li></ul> <div class="language-md extra-class"><pre class="language-md"><code>被动性 - 来自于控制反转
控制反转的主要作用是降低模块之间的依赖性，从而降低模块的耦合度和复杂度，
提高软件的可重用性、柔韧性和可扩展性，但对可伸缩性并无太大帮助
一般通过Callback实现，其目的是降低模块之间的依赖，从而降低模块的的耦合度和复杂度

异步性 - 来自于会话切换
由事件的不可预测性和随机性决定的
独立是异步的前提，耗时是异步的理由
异步过程在主程序中已非堵塞的机制运行，即主程序不必等待该过程的返回就能继续下一步。
异步机制能减少随机因素造成的资源浪费，提高系统的性能和可伸缩性。
</code></pre></div><ul><li>实现</li></ul> <blockquote><p>步骤</p></blockquote> <div class="language-md extra-class"><pre class="language-md"><code>实现事件处理器
注册事件处理器
实现事件循环
</code></pre></div><blockquote><p>事件机制设计需考虑的问题</p></blockquote> <div class="language-md extra-class"><pre class="language-md"><code>事件定义、事件触发、事件侦查、事件转化、事件合并、事件调度、事件传播、事件处理、事件连带（event cascade）等。
</code></pre></div><blockquote><p>一个典型的事件驱动模块</p></blockquote> <div class="language-md extra-class"><pre class="language-md"><code>事件处理器事先在关注的事件源上注册，后者不定期地发表事件对象，
经过事件管理器的转化（translate）、合并（coalesce）、排队（enquence）、分派（dispatch）等集中处理后，
事件处理器接收到事件并对其进行相应的处理。
</code></pre></div><ul><li>应用</li></ul> <div class="language-md extra-class"><pre class="language-md"><code>如果一个应用中，存在一些该类特质的因素，比如频繁的出现堵塞呼叫（blocking call），不妨考虑将其包装为事件

发行/订阅模式（publish-subscribe pattern）正是 观察者模式（observer pattern）的别名，
一方面可看作简化或退化的事件驱动式，另一方面可看作事件驱动式的核心思想。
该模式省略了事件管理器部分，由事件源直接调用事件处理器的接口。

MVC架构是观察者模式在架构设计上的一个应用
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/colon-classroom/assets/js/app.ec0b5e36.js" defer></script><script src="/colon-classroom/assets/js/2.8729a11c.js" defer></script><script src="/colon-classroom/assets/js/22.eccee837.js" defer></script>
  </body>
</html>
