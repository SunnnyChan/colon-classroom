(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{259:function(t,n,e){"use strict";e.r(n);var i=e(28),s=Object(i.a)({},(function(){var t=this.$createElement,n=this._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[n("h1",{attrs:{id:"_12-4-保变原则-与魔鬼打交道的艺术"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_12-4-保变原则-与魔鬼打交道的艺术"}},[this._v("#")]),this._v(" 12.4 保变原则——与魔鬼打交道的艺术")]),this._v(" "),n("div",{staticClass:"language-md extra-class"},[n("pre",{pre:!0,attrs:{class:"language-md"}},[n("code",[this._v("\t保变（Protected Variation，PV）是指受保护的变化。\n\t\t内容是：找出预计的变化点和不稳定点，分配其职责以便用稳定的接口和包装。\n\t\t该原则有助于构建低耦合高内聚系统。\n\t\t保变原则与单职原则一样，中心都是职责和变化。不过，保变原则着眼点更倾向变化，而单职原则的着眼点更倾向职责。\n\t\t\t前者侧重解决耦合问题，后者侧重解决内聚问题。\n\t封装是实现保变的一种技巧和手段\n\t\t保变涵盖的范围很广，可以是任何软件实体，包括模块、组件、子系统乃至系统。\n\t\t封装是类级别的保变，或者说是数据抽象层的保变。同理，子类型多态是接口级别的保变，或者说是多态抽象层的保变。\n\t软件最大的变数是客户的需求\n\t\t可维护性直接关乎软件的生命力，软件的可重用性主要是为了保证可维护性。\n\t\t\t所以可维护性是软件的设计质量最重要的标准。\n\t\t事实上，越是接近客户需求的类，越容易发生变化，稳定度就越低，有些修改时非常正常的。\n\t\t\t因此一味追求高可重用性，不仅是不必要的，更是不现实的。只要这种连带修改涉及面小，维护方便，即使可重用性低些有有何妨\n\t\t其实，当代码朝着高可维护性方向前进时，高可重用性也会如影随形。而一段容易维护的代码，又怎么会不够灵活、难以扩展，或者难以理解呢？\n\t\t对于维护者来说，变化是魔鬼。代码维护便是与魔鬼打交道。\n\t\t\t魔鬼代表变化，铁笼代表稳定的封装，孔代表对外的接口。这驯魔大法其实就是保变原则。\n\t\t\t保变原则是一个增加软件可维护性的通用而有效的方法。\n\t保变原则与间接原则异曲同工\n\t\t间接原则一个典型应用是：为解除两个模块之间的耦合，专门引入一个中间模块。\n\t\t耦合并不总是有害的，只有当其中潜藏的变化明显不利于将来的维护时，才有消除的必要。\n\t\t这个中间模块的作用，就是将此变化加以抽取和封装，并承担起中介的职责。\n\t保变原则与开闭原则也神似\n\t\t只是，保变原则提倡变中求稳，更侧重可维护性；开闭原则提倡稳中求变，更侧重可重用性。\n\t保变原则还暗含了迪米特法则（LoD）又称最少知识原则（Least Knowledge Principle， LKP），即不要与陌生人交谈（Don't talk to Strangers）。\n\t\t具体到应用到方法调用上，它要求一个对象的方法只能调用以下对象：改对象本身，即this或self；该方法的参数；该方法内部创建的对象；该对象直接组成对象，包括其属性及集合性属性中的元素。\n\t\tP384 图12-13 不满足LoD的实例\n\t\t如 obj.method1().method2().method3()之类的接龙式调用，大多都违背了迪米特法则。\n\t\t迪米特法则教导我们：可以信任朋友，但不可以信任朋友的朋友。\n\t\t\t换句话说，朋友关系没有传递性。\n\t\t\t在常见的封闭型多层架构中，上层只依赖相邻的下层，不能越层请求服务，也是同样的道理。\n\t\t\t每个模块都有清晰的逻辑边界和物理边界，但它的交际圈却没有。\n\t\t\t为了弥补这一缺憾，迪米特法则对模块的交际圈做出了明确的界定。如此一来，发生在模块上的变化受到双层保护：\n\t\t\t\t一层是模块自身的保护机制\n\t\t\t\t一层是模块的交际圈的保护机制\n\tGRASP 通用职责分配原则\n\t\t（General Responsibility Assignment Software Patterns/Principle） 通用职责分配原则\n\t\t\t它给出了如何合理的分配职责的方案。\n\t\t\t\t表12-1 GRASP\n\t\t信息专家（Information Expert） \n\t\t\t职责分配的基本原则是什么？  \n\t\t\t\t把职责分配给信息专家——拥有完成该职责所需信息的类。\n\t\t控制器（Controllor）\n\t\t\t谁负责处理系统事件？\n\t\t\t\t把处理系统事件的职责分配给代表整体系统或事件发生的用例场景（use case scenario）的类\n\t\t创建者（Creator）\n\t\t\t谁负责创建对象？\n\t\t\t\t把创建类A的实例的职责分配给类B，如果以下之一成立：\n\t\t\t\t\tB包含A；B聚合A；B记录A；B密切地使用A；B拥有A的初始化数据。\n\t\t低耦合（Low Coupling）\n\t\t\t如何支持低依赖、高重用？\n\t\t\t\t分配职责已保持低耦合度\n\t\t高内聚（High Cohesion）\n\t\t\t如果驾驭复杂性?\n\t\t\t\t分配职责以保持高内聚度\n\t\t多态（Polymorphism）\n\t\t\t当行为因类型而变化时，谁负责？\n\t\t\t\t当相关的备选方案或行为因为类型而变化，利用多态机制把职责分配给行为变化的类型\n\t\t纯虚构（Pure Fabrication）\n\t\t\t当你不想违背低耦合高内聚原则却又找不到合适的负责者时，该怎么办？\n\t\t\t\t将一组高内聚的职责类集合分配给一个虚构的“行为”类（即不代表问题领域的概念），以支持低耦合高内聚。\n\t\t间接（Indirection）\n\t\t\t如何分配职责以避免直接耦合？\n\t\t\t\t把职责分配给一个中介对象已避免两个组件或服务的直接耦合。\n\t\t保变（Protected Variations）\n\t\t\t如何好分配职责对象、子系统或系统，以使这些元素的变化不会影响到其它元素？\n\t\t\t\t找出预计的变化点或不稳定点，分配其职责以便用稳定的接口来包装。\n\t\t信息专家原则和纯虚构原则是关键，\n创建者原则和控制器原则可看作他们的应用。\n\t\t\t信息专家原则可归结为：知情者为负责者，即谁拥有完成职责所需的全部信息，谁就该负责。\n\t\t\t知情者太多是设计可能有缺陷的一个征兆，如果确实无法避免，就选育职责关联度最大的那位知情者。\n\t\t\t知情者具备了承担职责的基本能力，与相关信息也有一定的内置联系，让它来负责即是可能的，也是合理的。\n\t\t\t以信息专家作为职责分配的基本原则，可令系统的整体功能比较均匀地分散于各个类中。每当变化来临时，由于职责分工明确而公平，相关承担者很容易被识别且范围有限。同时职责分量不会太大，因而系统较易维护。\n\t\t\t信息专家原则多少还是增加了系统的耦合，当增加的耦合明显阻碍可维护性或可重用性时，就需要求助纯虚构原则了。\n\t\t\t\t所谓虚构，是指这种类有别于通常的类，并不代表问题领域中的概念，而是彻头彻尾的虚拟构想；所谓纯，是指虚构类的职责单纯是魏了支持低耦高聚，因而它的设计会显得很干净或纯净。\n\t\t\t\t比如，创建者原则建议：创建一个类的实例的职责分配给那些包含、聚合、记录或密切使用该类的类，或者拥有该类初始化数据的类。\n这个原则非常自然，算得上信息专家原则的一个推论，但同时也在两个类之间建立了强耦合。\n\t\t\t\t为此可以专门设计一个工厂类，接管创建对象的职责——这便是著名的工厂模式。\n\t\t\t\t\t该工厂类无疑符合纯虚构原则，因为工厂原本是不存在的。\n\t\t\t\t再如，控制器原则建议：把处理系统事件的职责分配给两种类，一种是代表整体系统的类，符合信息专家原则；一种是代表事件发生的用例场景，符合纯虚构原则。\n\t\t\t\t还有一个典型范例是领域驱动设计（domain-driven design）中的服务。\n\t\t\t\t\t它是不同于实体和值对象的一种特殊对象，不含任何状态，唯一的职责是把模型中相关的实体或值对象组织起来，为客户提供一些列的相关服务。\n\t\t\t\t\t每一种服务都是一种行为ie而非实体、动词而非名词的抽象，也是纯虚构原则的体现。\n\tSOLID 类设计原则\n\t\tSRP  一个类应当只由一个变更的理由\n\t\tOCP  软件实体对扩展开放，对修改封闭\n\t\tLSP  子类型必须能替换超类型\n\t\tISP  不应强迫客户依赖那些它们不用的方法\n\t\tDIP  抽象不应依赖细节，细节应当依赖对象\n\tSOLID 是牢固的意思，GRASP是掌握的意思，都是OOD的重要原则\n\t包（Package）级设计原则\n\t\t发布重用等价原则 REP（Release-Reuse Equivalency Principle） 重用的粒度是发布的粒度\n\t\t共同闭包原则 CCP （Common Closure Principle） 同一个包中的类应对同类变化封闭\n\t\t共同重用原则 CRP （Common Reuse Principle） 同一个包中的类一起被重用\n\t\t无环依赖原则 ADP （Acyclic Dependencies Principle） 在包的依赖图中不允许有环的存在\n\t\t稳定依赖原则 SDP （Stable Dependencied Principle） 朝着稳定的方向依赖\n\t\t稳定抽象原则 SAP （Stable Abstractions Principle） 一个包的抽象度应与其稳定度相当\n\t\t前3个是关于包的内聚原则，以解决包的颗粒度（granularity）问题，后3个是关于包的耦合原则，以解决包的稳定度（stability）问题。\n\t设计原则中的关键词和彼此之间的关系\n\t\tP382 图12-15 \n")])])])])}),[],!1,null,null,null);n.default=s.exports}}]);