(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{263:function(t,n,s){"use strict";s.r(n);var a=s(28),e=Object(a.a)({},(function(){var t=this.$createElement,n=this._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[n("h1",{attrs:{id:"_13-4-闭班小结-软件无形，编程有道"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_13-4-闭班小结-软件无形，编程有道"}},[this._v("#")]),this._v(" 13.4 闭班小结——软件无形，编程有道")]),this._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[this._v("一般的思想链：\n\t编程 => OOP => 可重用性 => 设计模式\n更好的思想链：\n\t编程 => 编程范式 => 可维护性 => 设计原则\n广度影响深度\n\tOOP是主流的编程范式，但不是唯一的方式，更不是任何场合都使用的范式。\n\t即使在OOP语言中，也不要局限于C++、Java、C#这类静态类型语言，对于动态语言类型语言和动态语言也同样要由于了解。\n\tOOP的最大价值也不是可重用性，而是为了解决软件的复杂问题提供了一种新的思维方式和抽象机制。\n对应可重用性\n\t它能大大提高软件开发效率，但如果不是在开发类库或框架之类专为重用的软件，请务必把软件可维护性优先级放在可重用性之前。因为软件维护期是软件生命周期中最长的阶段，人们往往关心的是如何用最小的代价来应对需求的变化。\n\t这并不意味着可重用性和可维护性有本质上的冲突，相反，它们在大多数情况下是一致的。\n\t不是所有的模式都必须百分之一百地遵守开闭原则的，尤其是那些不打算被重用的模块。\n")])])]),n("p",[this._v("是的，有些模块天生就是要修改的，它们不需要被重用，也不打算重用，因为它们是与变化战斗的第一线代码。\n这是现实，也是常态，无法逃避，必须面对。\n应对变化\n我们需要做的不是祈祷变化的魔鬼永远不要降临，而是未雨绸缪地打造坚固的牢笼，守候在它们的必经之处。\n不怕变化，就怕不能控制变化；不怕修改，就怕不知何处修改。\n重用\n一般提起重用，通常是指代码重用。\n其实还可以有更高级的设计重用、分析重用、概念重用、规范重用、思想重用等。\n设计模式可以认为是一种思想重用，同样的设计模式因不同的语言、不同的需求而有不同的实现，但总体思想是不变的。\n这也是设计模式的价值所在。\n另外我们强调规范重用，实现继承是代码重用，接口继承是规范重用。")])])}),[],!1,null,null,null);n.default=e.exports}}]);